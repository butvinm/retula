*$FROM LibraryEx
$EXTERN LoadFile, MapAccum, Inc, ArgList, Trim;


*$FROM Machine.ref
$EXTERN Rule, Rule-Create, Machine, Machine-Create, Machine-State, Machine-Rules, Machine-AppendRule, Machine-Tape;


$ENTRY Go {
  = <ArgList> : {
    t._ (e.SourceFile) = <Eval <LoadFile e.SourceFile>>;
    e._ = <Prout 'Usage: retula <file>'>;
  };
}


Eval {
  e.Code = <MapAccum &EvalLine <Machine-Create> e.Code>;
}


EvalLine {
  t.Machine t.Line = <SwEvalLine t.Machine t.Line>;
}


SwEvalLine {
  t.Machine ('case ' e.RuleDefinition) = <EvalRuleDefinition t.Machine (e.RuleDefinition)>;
  t.Machine ('trace ' e.TraceDefinition) = <EvalTraceDefinition t.Machine (e.TraceDefinition)>;
  t.Machine (/* empty */) = t.Machine;
}


EvalRuleDefinition {
  t.Machine (e.RuleState ' ' e.RuleRead ' ' e.RuleWrite ' ' e.RuleStep ' ' e.RuleNext)
    = <Rule-Create (e.RuleState) (e.RuleRead) (e.RuleWrite) (e.RuleStep) (e.RuleNext)> : t.Rule
    = <Machine-AppendRule t.Machine t.Rule>;
}


EvalTraceDefinition {
  t.Machine (e.InitState ' ' e.InitTape)
    = <Split e.InitTape> : t.InitTapeH e.InitTapeR
    = <Machine-Tape t.Machine (() t.InitTapeH (e.InitTapeR))> : t.Machine^
    = <Machine-State t.Machine (e.InitState)> : t.Machine^
    = <EvalTrace t.Machine>;
}


EvalTrace {
  [Machine (State 'Halt') (Rules e.Rules) (Tape e.Tape)]
    = <Prout
      'Machine stopped:\n'
      '    State: Halt\n'
      '    Rules: ' e.Rules '\n'
      '    Tape: ' e.Tape
    > :
    = <Exit 0>;

  t.Machine
    = t.Machine : [Machine (State e.State) (Rules e.Rules) (Tape (e.TapeL) (e.TapeH) (e.TapeR))]
    = <FindRule t.Machine> : {
      None = t.Machine;
      [Rule (State e._) (Read e._) (Write e.Write) (Step e.Step) (Next e.Next)]
        = <Machine-State t.Machine (e.Next)> : t.Machine^
        = e.Step : {
          '->'
            = e.TapeR : (e.TapeH^) e.TapeR^
            = <Machine-Tape t.Machine ((e.TapeL e.Write) (e.TapeH) (e.TapeR))> : t.Machine^
            = <EvalTrace t.Machine>;

          '<-'
            = e.TapeL : e.TapeL^ (e.TapeH^)
            = <Machine-Tape t.Machine ((e.TapeL) (e.TapeH) (e.Write e.TapeR))> : t.Machine^
            = <EvalTrace t.Machine>;

          '.'
            = <Machine-Tape t.Machine ((e.TapeL) (e.Write) (e.TapeR))> : t.Machine^
            = <EvalTrace t.Machine>;
        };
    };
}


FindRule {
  t.Machine
    = t.Machine : [Machine (State e.State) (Rules e.Rules) (Tape (e.TapeL) (e.TapeH) (e.TapeR))]
    = e.Rules : {
      /* empty */ = None;
      t.Rule e.RestRules
        = t.Rule : {
          [Rule (State e.State) (Read e.TapeH) e.Params-E] = t.Rule;
          e._ = <FindRule <Machine-Rules t.Machine (e.RestRules)>>;
        };
    };
}

Eq {
  (e.A) e.A = True;
  (e.A) e.B = False;
}


Split {
  e.Str = <Trim e.Str> : {
    e.Part ' ' e.Rest = (e.Part) <Split e.Rest>;
    e.Part = (e.Part);
  };
}
