*$FROM LibraryEx
$EXTERN LoadFile, MapAccum, Inc, ArgList, Trim;


$ENTRY Go {
  = <ArgList> : {
    t._ (e.SourceFile) = <Eval <LoadFile e.SourceFile>>;
    e._ = <Prout 'Usage: retula <file>'>;
  };
}


Eval {
  e.Code = <DoEval () () (() ('1') (('1') ('0') ('0') ('0') ('1') ('&'))) e.Code>;
}


DoEval {
  t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR)) e.Code
    = <MapAccum &EvalLine (t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR))) e.Code>;
}


EvalLine {
  (t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR))) (e.Line)
    = (<SwEvalLine t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR)) e.Line>);
}


SwEvalLine {
  t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR)) 'case ' e.RuleDefinition
    = <EvalRuleDefinition t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR)) e.RuleDefinition>;

  t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR)) 'trace ' e.TraceDefinition
    = <EvalTraceDefinition t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR)) e.TraceDefinition>;

  t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR)) /* empty */
    = t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR));
}


EvalRuleDefinition {
  t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR)) e.RuleState ' ' e.RuleRead ' ' e.RuleWrite ' ' e.RuleStep ' ' e.RuleNext
    = (Rule (e.RuleState) (e.RuleRead) (e.RuleWrite) (e.RuleStep) (e.RuleNext)) : t.Rule
    = t.State (e.Rules t.Rule) ((e.TapeL) t.TapeH (e.TapeR));
}


EvalTraceDefinition {
  t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR)) e.InitState ' ' e.InitTape
    = <Split e.InitTape> : t.InitTapeH e.InitTapeR
    = <EvalTrace (e.InitState) (e.Rules) (() t.InitTapeH (e.InitTapeR))>;
}


EvalTrace {
  ('Halt') (e.Rules) ((e.TapeL) t.TapeH (e.TapeR))
    = <Prout
      'Machine stopped:\n'
      '    State: Halt\n'
      '    Rules: ' (e.Rules) '\n'
      '    Tape: ' ((e.TapeL) t.TapeH (e.TapeR))
    > :
    = <Exit 0>;

  t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR))
    = <Prout
      'Trace step:\n'
      '    State: ' t.State '\n'
      '    Rules: ' (e.Rules) '\n'
      '    Tape: ' ((e.TapeL) t.TapeH (e.TapeR))
    > :
    = <FindRule t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR))> : t.Rule
    = t.Rule : {
      (Rule t.RuleState t.RuleRead t.RuleWrite t.RuleStep t.RuleNext)
        = <Prout '    Matched rule: ' t.Rule> :
        = t.RuleStep : {
          ('->')
            = e.TapeR : t.TapeNewHead e.TapeR^
            = <EvalTrace t.RuleNext (e.Rules) ((e.TapeL t.RuleWrite) t.TapeNewHead (e.TapeR))>;

          ('<-')
            = e.TapeL : t.TapeNewHead e.TapeL^
            = <EvalTrace t.RuleNext (e.Rules) ((e.TapeL) t.TapeNewHead (e.TapeR t.RuleWrite))>;

          ('.')
            = <EvalTrace t.RuleNext (e.Rules) ((e.TapeL) t.TapeH (e.TapeR))>;
        };

      None
        = <Prout '    Rule not found'> :
        = t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR));
    };
}


FindRule {
  t.State () ((e.TapeL) t.TapeH (e.TapeR)) = None;

  t.State (t.Rule e.Rules) ((e.TapeL) t.TapeH (e.TapeR))
    = t.Rule : (Rule t.RuleState t.RuleRead t.RuleWrite t.RuleStep t.RuleNext)
    = t.RuleState t.RuleRead : {
      t.State t.TapeH = t.Rule;
      e._ = <FindRule t.State (e.Rules) ((e.TapeL) t.TapeH (e.TapeR))>;
    };
}


Eq {
  (e.A) e.A = True;
  (e.A) e.B = False;
}


Split {
  e.Str = <Trim e.Str> : {
    e.Part ' ' e.Rest = (e.Part) <Split e.Rest>;
    e.Part = (e.Part);
  };
}
